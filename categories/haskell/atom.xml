<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Haskell | Abizer Nasir]]></title>
  <link href="http://abizern.org/categories/haskell/atom.xml" rel="self"/>
  <link href="http://abizern.org/"/>
  <updated>2013-03-02T12:02:27+00:00</updated>
  <id>http://abizern.org/</id>
  <author>
    <name><![CDATA[Abizer Nasir]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[An improved Reverse Words Script]]></title>
    <link href="http://abizern.org/2012/10/31/an-improved-reverse-words-script/"/>
    <updated>2012-10-31T09:19:00+00:00</updated>
    <id>http://abizern.org/2012/10/31/an-improved-reverse-words-script</id>
    <content type="html"><![CDATA[<p>About 6 months ago I posted
<a href="http://abizern.org/2012/04/09/reverse-words-with-haskell/">a solution</a> to the
Google Code Jam problem
<a href="http://code.google.com/codejam/contest/351101/dashboard#s=p1" title="Original problem statement">Reverse Words</a></p>

<p>I've become more comfortable with Haskell since then, so here's an improved solution.</p>

<!-- more -->


<p><div><script src='https://gist.github.com/3986006.js'></script>
<noscript><pre><code></code></pre></noscript></div>
</p>

<p>I'm not one who believes that shorter, terser code is necessarily better, but
that isn't what makes this version an improvement. Nor even the use of Monads;
Haskell's sexy buzzword. I think this code is better because it has less noise
than the original solution.</p>

<p>Code Jam problems have well defined inputs and required outputs, and there is no
need to load the whole input file when the script starts. Normally, I would be
all for splitting out code into smaller, descriptively named functions, but in
this small case that's just more typing and more lines getting in the way of the
actual solution. I think that this version is more readable because there are
less lines of code that don't contribute directly to the solution.</p>

<p>And Code Jam has a time limit, so smaller code is faster to write and easier to
debug.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On Live Coding]]></title>
    <link href="http://abizern.org/2012/08/20/on-live-coding/"/>
    <updated>2012-08-20T12:34:00+01:00</updated>
    <id>http://abizern.org/2012/08/20/on-live-coding</id>
    <content type="html"><![CDATA[<p>I read somewhere that part of the popularity of
<a href="http://en.wikipedia.org/wiki/The_West_Wing">The West Wing</a> was that it was
entertaining to watch smart people solve difficult problems. I think that's part
of the reason why I find watching live coding videos so entertaining - It's more
fun to watch someone solve a problem than doing it yourself.</p>

<!-- more -->


<p>There are plenty of screencasts you can find - <a href="http://youtubecom">YouTube</a> is
an obvious one, but don't forget <a href="http://vimeo.com">Vimeo</a>.</p>

<p>Some good ones to watch are the
<a href="https://peepcode.com/screencasts/play-by-play">Play-By-Play</a> series produced by
<a href="http://peepcode.com">Peepcode</a> These screencasts have a developer solving a
problem set by the host as he talks to them about the choices they make and the
tools they use. Mostly Ruby / Railsy, but there are exceptions - Zed Shaw and
Python, Ryan Singer designing a UX workflow for the Web, Kyle Neath on UI
Workflow, and the latest has Tim Caswell creating a node.js web app.</p>

<p>These are not only interesting screencasts, with plenty to learn from, but I
find they are great for background noise. I work at home, and having the sounds
of a keyboard clacking and techy conversation pushes back the silence. Also,
when you look at a tutorial type blog post - or something on GitHub, all you see
is the finished product. But when you watch someone working, you realise that it
doesn't come out fully formed like that, it sort of evolves. The same way that
you evolve code.</p>

<p>I did my own small one about
<a href="http://abizern.org/2012/04/09/reverse-words-with-haskell/">reversing words in Haskell</a>
a few months ago and I found that it's harder to do than it looks. I credited
<a href="http://codinguncut.com/">Jonas Tullus</a> as an influence for that screencast and now
see that he has started <a href="http://codinguncut.com">Coding Uncut</a>, where he takes
on a problem and screencasts his solution in Haskell. This is harder to do than
the Peepcode ones, because without anyone asking you questions you become more
self-conscious about vocalising your thoughts.</p>

<p>Some of the things I've picked up from watching these are:</p>

<ul>
<li>It's okay to spend your time looking up the documentation. Knowing roughly
what approach to take to a solution and then looking up the details is more
important.</li>
<li>It's faster to try something and see what happens rather than overthinking
everything from the beginning.</li>
<li>Version control is not an optional extra (okay, I already believe this, but
it's nice to see that I'm not the only one).</li>
<li>It's not the tool that matters - Emacs, Vim, JEdit, Paper and Sharpie - but
how you use it.</li>
<li>"It's not about the code. It's your understanding of the problem that you're
working on." - Zed Shaw</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rotate A String with Haskell]]></title>
    <link href="http://abizern.org/2012/04/15/rotate-a-string-with-haskell/"/>
    <updated>2012-04-15T15:08:00+01:00</updated>
    <id>http://abizern.org/2012/04/15/rotate-a-string-with-haskell</id>
    <content type="html"><![CDATA[<p>I qualified for <a href="http://code.google.com/codejam">Google Code Jam</a> this year
answering 3 out of 4 questions. I have no illusions about progressing very far,
but I'm using it as an excuse to learn some Haskell and to write code faster.</p>

<p>As part of the learning process, I took one of my correct solutions over to the
nice folks at the #haskell channel over on freenode and asked if there was a
better way to do it. I learned something surprising.</p>

<!-- more -->


<p>As part of the solution to the
<a href="http://code.google.com/codejam/contest/1460488/dashboard#s=p2">Recycled Numbers</a>
problem required turning a number such as 1234 into a list of numbers with the
digits rotated [4123, 3412, 2341]. User TSC2 in the channel gave me this simple
way of doing it:</p>

<p><code>bash ghci console
ghci&gt; (\xs -&gt; let n = length xs in (tail . take n . map (take n) . tails . cycle) xs) "abcde"
["bcdea","cdeab","deabc","eabcd"]
</code></p>

<p>I'm still new to this so I had to work it out on paper, but here is a step by
step explanation of what is happening: working from right to left as the
functions are evaluated:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>xs </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"abcde"</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><code>xs</code> is just the input string.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>cycle </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"abcdeabcde..."</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><code>cycle</code> creates an infinite list out of the input list by repeating it. Haskell
is lazy. It doesn't actually create the list until it actually needs it, so I've
added the ellpises just to show the concept that this is repeated infinitely.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>tails </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>["abcdeabcde...", "bcdeabcdea...", "cdeabcdeab...", "deabcdeabc...", ...]</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This is where things start to get interesting. <code>tails</code> creates a list out of
successive tails of a list. If you were to do this on a finite list you'd get a
list of smaller and smaller elements. For example:</p>

<p><code>bash ghci console
ghci&gt; tails "abcde"
["abcde","bcde","cde","de","e",""]
</code></p>

<p>But since our input is an infinite we now have an infinite list of infinite
lists, each element starting at one letter in from the original list. Remember,
this hasn't actually been worked out yet.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>map (take n) </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>["abcde", "bcdea", "cdeab", "deabc", "eabcd" "abcde", ...]</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><code>take n</code> takes the first <code>n</code> elemets of a list. Our lambda expression defines
this as the length of the list, which is 5. And <code>map</code> applies this to each
element of the list. So now we have an infinite list of 5 element lists. which is
closer to our required final output.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>take n </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>["abcde", "bcdea", "cdeab", "deabc", "eabcd"]</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Applying <code>take n</code> again to the infinite list takes the first 5 elements of the
finite list</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>tail </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>["bcdea", "cdeab", "deabc", "eabcd"]</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Applying <code>tail</code> to the finite list takes all but the first element, and we get
the output that we were looking for. Even though along the way we had an
infinite list of infinite lists.</p>

<p>And yet all Haskell did was provide a promise (a <em>thunk</em> in functional terms)
that it would provide the answer when it was asked for, and as the function
progressed the infinite list of infinite list became an infinite list of finite
lists and then a finite list. And still it didn't actually resolve all those
calls until it was actually needed. In this case, when the <em>ghci</em> interpreter
tried to get a string to display on the screen.</p>

<p>Freaky or what?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reverse Words With Haskell]]></title>
    <link href="http://abizern.org/2012/04/09/reverse-words-with-haskell/"/>
    <updated>2012-04-09T15:41:00+01:00</updated>
    <id>http://abizern.org/2012/04/09/reverse-words-with-haskell</id>
    <content type="html"><![CDATA[<p>As part of my preparation for <a href="http://code.google.com/codejam">Google Code Jam</a>
I've been working through the practice problems with Haskell.</p>

<p>I made a screencast on solving the
<a href="http://code.google.com/codejam/contest/351101/dashboard#s=p1">Reverse Words</a>
problem, along with the mechanics of getting the problem inputs and submitting solutions. The style was heavily influenced by a sequence on
<a href="http://youtu.be/045422s6xik?hd=1">Data Driven Programming in Haskell</a> by
<a href="http://entirelysubjective.com/programming/data-driven-programming-haskell-1/">Jonas Tullus</a></p>

<!-- more -->


<p>I moved at a slower pace, and talking and typing seem to have confused my brain
so I think I lapsed into gibberish in a couple of places. (If you know me,
you'll know that's nothing new).</p>

<p><iframe width="640" height="510" src="http://www.youtube.com/embed/_tgv3HVgOMc  " frameborder="0" allowfullscreen></iframe></p>

<p>Here's the cleaned up source file.</p>

<p><div><script src='https://gist.github.com/2368757.js'></script>
<noscript><pre><code></code></pre></noscript></div>
</p>

<p>I need to learn more Emacs shortcuts :(</p>
]]></content>
  </entry>
  
</feed>
